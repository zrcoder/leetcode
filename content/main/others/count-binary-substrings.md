---
title: "计数二进制子串"
date: 2021-04-23T17:00:28+08:00
weight: 1
---

## [696. 计数二进制子串](https://leetcode-cn.com/problems/count-binary-substrings/)

难度简单

给定一个字符串 `s`，计算具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是连续的。

重复出现的子串要计算它们出现的次数。

**示例 1 :**

```
输入: "00110011"
输出: 6
解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。

请注意，一些重复出现的子串要计算它们出现的次数。

另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
```

**示例 2 :**

```
输入: "10101"
输出: 4
解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。
```

**提示：**

- `s.length` 在1到50,000之间。
- `s` 只包含“0”或“1”字符。

函数签名：

```go
func countBinarySubstrings(s string) int
```

## 分析

连续的一串 0 和紧邻它的连续的一串 1 可以组成一个满足约束的字串。

```
...00000011111...
...{s0}{s1}...
```

满足约束的字串长度是：`min(len(s0), len(s1))`。

一串 1 和紧邻它的一串 0 的情况也是类似的。

```go
func countBinarySubstrings(s string) int {
	preLen, res := 0, 0
	for i := 0; i < len(s); {
		j := i
		for j < len(s) && s[j] == s[i] {
			j++
		}
		curLen := j - i
		res += min(curLen, preLen)
		preLen = curLen
		i = j
	}
	return res
}
```

时间复杂度 `O(n)`，空间复杂度 `O(1)`。

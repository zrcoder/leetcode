---
title: 2009. 使数组连续的最少操作数
date: 2024-04-08T10:17:30+08:00
---

## [2009. 使数组连续的最少操作数](https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-continuous) (Hard)

给你一个整数数组 `nums` 。每一次操作中，你可以将 `nums` 中 **任意** 一个元素替换成 **任意** 整数。

如果 `nums` 满足以下条件，那么它是 **连续的** ：

- `nums` 中所有元素都是 **互不相同** 的。
- `nums` 中 **最大** 元素与 **最小** 元素的差等于 `nums.length - 1` 。

比方说， `nums = [4, 2, 5, 3]` 是 **连续的** ，但是 `nums = [1, 2, 3, 5, 6]` **不是连续的** 。

请你返回使 `nums` **连续** 的 **最少** 操作次数。

**示例 1：**

```
输入：nums = [4,2,5,3]
输出：0
解释：nums 已经是连续的了。

```

**示例 2：**

```
输入：nums = [1,2,3,5,6]
输出：1
解释：一个可能的解是将最后一个元素变为 4 。
结果数组为 [1,2,3,5,4] ，是连续数组。

```

**示例 3：**

```
输入：nums = [1,10,100,1000]
输出：3
解释：一个可能的解是：
- 将第二个元素变为 2 。
- 将第三个元素变为 3 。
- 将第四个元素变为 4 。
结果数组为 [1,2,3,4] ，是连续数组。

```

**提示：**

- `1 <= nums.length <= 10⁵`
- `1 <= nums[i] <= 10⁹`

## 分析

首先将数组排序，这样可以用滑动窗口的方式确定连续子数组：对于窗口[lo, hi] ，枚举hi，将 nums[hi] 看作最终连续子数组的最大值，那么最小值应该是 nums[hi]-n+1，对比 nums[lo] 和这个最小值，如果 nums[lo] 小于该值，则 lo++

即保持窗口里的元素为以窗口右端点为最大值的连续子数组（部分元素缺失），在窗口滑动过程中，维护窗口最大长度res，最终结果就是 n-res

> 细节：重复的元素不应在窗口里，否则会算多窗口长度，需要去重


```go
func minOperations(nums []int) int {
	n := len(nums)
	slices.Sort(nums)
	nums = slices.Compact(nums)
	res := 0
	lo := 0
	for hi, v := range nums {
		for nums[lo] < v-n+1 {
			lo++
		}
		res = max(res, hi-lo+1)
	}
	return n - res
}

```
